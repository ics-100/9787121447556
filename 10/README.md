# 第 10 章 中断和动态时钟显示

|本期版本|上期版本
|:---:|:---:|
`Thu Apr 11 23:40:20 CST 2024` | 

## 10.1 外部硬件中断

**通过两个引脚来区别对待不同的中断信号**

* 可屏蔽中断： 对于那些不不紧急，不用着急处理的中断信号，应该从 `INTR` 引脚输入
* 非屏蔽中断： 所有严重事件都必须无条件地加以处理，由这类事件引发的中断信号应当通过 `NMI` 引脚送入处理器

### 10.1.1 非屏蔽中断

* 尽管非屏蔽中断在处理器内部是不可屏蔽的，**但是在处理器外部却有一个开关控制非屏蔽中断信号能否进入处理器**
* 每种类型的中断都被统一编号，这称为**中断号**
* 在实模式下，NMI被赋予了统一的中断号2，不在进行细分

### 10.1.2 可屏蔽中断

* 中断屏蔽寄存器(Interrupt Mask Register, IMR), 这是8位寄存器，对应着该芯片的8个中断输入引脚，`0`表示允许，`1`表示阻断
* 主片的端口是 `0x20` 和 `0x21`，从片的端口是 `0xa0 和0xa1`

**中断标志(Interrupt Flag, IF)** 

* 0: 忽略 / `cli`
* 1: 接受 / `sti`

### 10.1.3 实模式下的中断向量表

* 中断向量表（Interrupt Vector Table， IVT）: 从物理地址`0x00000`开始到 `0x003ff`结束，共 1KB的空间
* 每个中断在中断向量表中占 2 个字，分别是中断处理程序的偏移地址和逻辑段地址

---

> 1 - 保护断点的现场

* 标志寄存器 FLAGS 压栈, 然后清楚它的IF位和TF位
* 再将 CS 和 IP 压栈

> 2 - 执行中断程序

* 中断号**乘4获**取中断向量表偏移地址
* 从向量表中获取偏移地址和段地址, 并分别传送到IP和CS

> 3 - 返回断点接着执行

* 最后一条指令必须是中断返回指令 `iret` (从栈中弹出: IP、CS、FLAGS)


### 10.1.4 实时时钟、CMOS RAM 和 BCD编码

**CMOS RAM的访问**

* `0x70`或者 `0x74` 是索引端口
* `0x71`或者 `0x75` 是数据端口

**NMI**

* 尽管处理器始终会无条件处理从NMI引脚来的非屏蔽中断，但是非屏蔽中断能否到达处理器的NMI引脚，却是受控制的
* 从很早的时候，端口 0x70 的最高位(bit 7) 是控制NMI中断开关的。0允许 / 1阻断
* 其它7个比特，即0～6位，则实际上用于指定 CMOS RAM单元的索引
* **NMI 中断应当始终是允许的，在访问RTC是，我们直接关闭NMI，访问结束后，在打开NMI**

**BCD**

* 二进制编码的十进制数
* 一个字节的高4位和低4位分别独立地表示一个0到9之间的数字

### 10.1.5 实时时钟 RTC 的中断信号

**周期性中断(Periodic Interrupt, PF)**

> 就是每隔一段时间重复发生一次

* 寄存器A(6~4): 外部时钟频率
* 寄存器A(3~0): 发生的速率
* 寄存器B(6): 周期性中断允许位

**更新周期结束中断(Update-ended Interrupt, UI)**

* 每隔一秒，实时时钟电路将更新CMOS RAM里面的时间和日期
* 寄存器B(7): 这一位叫做SET， 用来允许或者禁止更新周期

**闹钟中断(Alarm Interrupt, AI)**

* 寄存器B(5): 闹钟中断允许位

**当中断发生时，如何知道发生了那一种中断呢？**

> 寄存器C是只读的，不能写入。寄存器C是对读操作敏感的，读操作将导致所有比特清零


* 实时时钟芯片的中断信号通过一根线链接到8259A从片的第一个引脚IR0
* 在计算机启动后，BIOS程序将它的中断号初始化位 0x70
* 寄存器C(7): 如果有中断发生，则位7是1
* 寄存器C(6): 周期性中断标志
* 寄存器C(5): 闹钟中断标志
* 寄存器C(4): 更新结束标志

### 10.1.7 初始化 8259、RTC和中断向量表

*  主片中断号设为`0x08`开始，将从片的中断号设为从`0x70`开始

### 10.1.8 使处理器进入低功耗状态

* `hlt` 指令使处理器停止执行指令，并出去停机状态，这将降低处理器的功耗
* 处于停机状态处理器可以被外部中断唤醒并恢复执行，而且会继续执行htl后面的指令


### 10.1.9 实时时钟中断的处理过程

* test 指令在功能上和and指令是一样的，都是将两个操作数按位进行逻辑“与”，并根据结果设置相应的标志位

## 10.2 内部中断

* 内部中断不受标志寄存器的 `IF` 位的影响

## 10.3 软中断

### 9.3.1 BIOS 中断

* int 指令不需要知道目标程序的入口地址
* 最有名的软中断是 BIOS 中断, 之所以称为 BIOS 中断，是因为这些中断功能是在计算机加电之后，BIOS程序执行期间建立的
* 为了区分针对同一硬件的不同功能，使用寄存器 AH 来制定具体的功能编号

---

> 有一些BIOS中断是由外部设备接口自己建立的

* 前两个单元的内容是0x55和0xaa
* 第三个单元是本ROM以512字节为单位的代码长度
* 从第4个单元开始，就是实际的ROM代码
* **BIOS程序会以2KB为单位搜索内存地址C000~E0000之间的区域**


### 10.3.3 从键盘读取字符并现实

* 向屏幕上写字符使用的是BIOS中断，具体来说就是中断 `0x10`的 `0x0e` 号功能
* `0x16` 从键盘读取字符，需要在寄存器  AH 中指定 `0x00`号功能

