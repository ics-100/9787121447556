# 第 7 章 相同的功能，不同的代码

|本期版本|上期版本|
|:---:|:---:|
|`Thu Apr 11 12:25:45 CST 2024`| -

## 7.3 在数据声明中使用字面值

* 在 NASM 里，`\` 是续行符，当一行写不下时，可以在行尾使用这个符号，以表明下一行与当前行应该合并为一行

## 7.4 段地址的初始化

* 汇编语言的编译符合一种假设，即编译后的代码将从某个内存段中，偏移地址为 `0` 的地方开始加载
* `0x0000:0x7C00` 、`0x07c0:0x0000`
* 我们可以把这 512 字节的区域堪称一个单独的段，段的基地址是 `0x7C00`

## 7.5 段之间的批量数据传送

* 原始数据串的段地址由DS指定，偏移地址由SI指定，简写为DS:SI
* 要传送的目的地址由ES:DI指定
* 传送的字节数(movsb)或者字数(movsw)由CX指定
* 正向传送是指传送操作的方式从内存区域的低地址端到高地址端
* 每传送一次，CX的内容自动减1， 因为CX用来指定传送的次数
* 正向传送时，每传送一子节或者一个字时SI和DI加1或者加2

**传送方向**

* 在8086 处理器里，有一个特殊的寄存器，叫做标志寄存器 `FLAGS`
* 位 10 是方向标志DF（Direction Flag），通过将这一位清0或者置1，就能控制 `movsb` 和 `movsw` 的传送方向
* `cld: 0` 指示正向传送、`std: 1`: 指示反向传送
* 指令前缀`rep` 的意思是 `CX` 不为零则重复


## 7.6 使用循环分解位数

**循环**

```asm
loop digit
```
* * `loop` 指令的功能是重复执行一段相同的代码
* 将寄存器CX的内容减1
* 如果寄存器CX的内容不为零，转移到指定的位置出执行，否则顺序执行后面的指令
* 在 8086 处理器上，如果要用寄存器来提供偏移地址，只能使用 BX、SI、DI、BP,不能使用其他寄存器

## 7.7 计算机中的负数


### 7.7.1 无符号数和有符号数

* 因为 `-1` 其实等于 `0-1`
* 有符号数是分正负的，而且规定，数的正负要通过它的最高位来辨别。如果高位时0，它就是正数；如果是1，就是负数
* 正的有符号数，和与它同值的无符号数相同
* 负数都是用 0 减去它们对应的正数得到的
* **一个8位的有符号数，要想用16位的形式表示，只需将其最高位，扩展到高8位即可**
* cbw(Convert Byte to Word)、cwd(Convert Word To Double-word)

## 7.8 数位的显示

* 传送结束后，寄存器DI 正好指向字符":"的下一个存储单元。之后寄存器DI一直没用过，还保持着原先的内容
* `jns show`的意思是，如果未设置符号位，则转移到标号`show`
* 如果计算结果的最高位是比特`0`, 处理器把`SF` 位置 `0`, 否则置为`1`

## 7.9 其他标志位和条件转移指令

### 7.9.5 条件转移指令

* `jns` 意识是 `SF!=`(那就是SF=0),则转移
* `cmp` 指令的功能上和 `sub` 指令相同，唯一不同之处是， `cmp` 指令仅仅根据计算的结果设置相应的标志位，而不保留计算结果
* `jcxz` 当CX寄存器的内容为零时则转移

## 7.10 NASM 编译器的\$和\$\$标记

* `$`: 当前行的汇编地址
* `$$`: 当前汇编段的起始汇编地址